Methods with `self` or `cls` annotations: 523
    def __enter__(self: _TC) -> _TC: ...

    @classmethod
    def from_private_key_file(cls: Type[_PK], filename: str, password: Optional[str] = ...) -> _PK: ...

    @classmethod
    def from_private_key(cls: Type[_PK], file_obj: IO[str], password: Optional[str] = ...) -> _PK: ...

    def __enter__(self: _T) -> _T: ...

    @classmethod
    def supported_key_format_identifiers(cls: Any) -> List[str]: ...

    def copy(self: _S, **add_or_replace: _VT) -> _S: ...

    def __enter__(self: _SelfT) -> _SelfT: ...

    @overload
    def __init__(
        self: Connection[Cursor],  # different between overloads
        *,
        host: str | None = ...,
        user: Any | None = ...,
        password: str = ...,
        database: Any | None = ...,
        port: int = ...,
        unix_socket: Any | None = ...,
        charset: str = ...,
        sql_mode: Any | None = ...,
        read_default_file: Any | None = ...,
        conv=...,
        use_unicode: bool | None = ...,
        client_flag: int = ...,
        cursorclass: None = ...,  # different between overloads
        init_command: Any | None = ...,
        connect_timeout: int | None = ...,
        ssl: Mapping[Any, Any] | None = ...,
        ssl_ca=...,
        ssl_cert=...,
        ssl_disabled=...,
        ssl_key=...,
        ssl_verify_cert=...,
        ssl_verify_identity=...,
        read_default_group: Any | None = ...,
        compress: Any | None = ...,
        named_pipe: Any | None = ...,
        autocommit: bool | None = ...,
        db: Any | None = ...,
        passwd: Any | None = ...,
        local_infile: Any | None = ...,
        max_allowed_packet: int = ...,
        defer_connect: bool | None = ...,
        auth_plugin_map: Mapping[Any, Any] | None = ...,
        read_timeout: float | None = ...,
        write_timeout: float | None = ...,
        bind_address: Any | None = ...,
        binary_prefix: bool | None = ...,
        program_name: Any | None = ...,
        server_public_key: bytes | None = ...,
    ): ...

    @overload
    def __init__(
        self: Connection[_C],  # different between overloads
        *,
        host: str | None = ...,
        user: Any | None = ...,
        password: str = ...,
        database: Any | None = ...,
        port: int = ...,
        unix_socket: Any | None = ...,
        charset: str = ...,
        sql_mode: Any | None = ...,
        read_default_file: Any | None = ...,
        conv=...,
        use_unicode: bool | None = ...,
        client_flag: int = ...,
        cursorclass: Type[_C] = ...,  # different between overloads
        init_command: Any | None = ...,
        connect_timeout: int | None = ...,
        ssl: Mapping[Any, Any] | None = ...,
        ssl_ca=...,
        ssl_cert=...,
        ssl_disabled=...,
        ssl_key=...,
        ssl_verify_cert=...,
        ssl_verify_identity=...,
        read_default_group: Any | None = ...,
        compress: Any | None = ...,
        named_pipe: Any | None = ...,
        autocommit: bool | None = ...,
        db: Any | None = ...,
        passwd: Any | None = ...,
        local_infile: Any | None = ...,
        max_allowed_packet: int = ...,
        defer_connect: bool | None = ...,
        auth_plugin_map: Mapping[Any, Any] | None = ...,
        read_timeout: float | None = ...,
        write_timeout: float | None = ...,
        bind_address: Any | None = ...,
        binary_prefix: bool | None = ...,
        program_name: Any | None = ...,
        server_public_key: bytes | None = ...,
    ): ...

    def __iter__(self: Type[_T]) -> Iterator[_T]: ...

    def __reversed__(self: Type[_T]) -> Iterator[_T]: ...

    def __getitem__(self: Type[_T], name: str) -> _T: ...

    @property
    def __members__(self: Type[_T]) -> Mapping[str, _T]: ...

    def __new__(cls: Type[_T], value: object) -> _T: ...

    def __contains__(self: _T, other: _T) -> bool: ...

    def __or__(self: _T, other: _T) -> _T: ...

    def __and__(self: _T, other: _T) -> _T: ...

    def __xor__(self: _T, other: _T) -> _T: ...

    def __invert__(self: _T) -> _T: ...

    def __or__(self: _T, other: Union[int, _T]) -> _T: ...

    def __and__(self: _T, other: Union[int, _T]) -> _T: ...

    def __xor__(self: _T, other: Union[int, _T]) -> _T: ...

    def __enter__(self: _T) -> _T: ...

    def __call__(self: _T, n: int) -> _T: ...

    def normalized(self: _SelfT) -> _SelfT: ...

    # TODO: use Union when mypy will handle it properly in overloaded operator
    # methods (#2129, #1442, #1264 in mypy)
    @overload
    def __add__(self: _SelfT, other: relativedelta) -> _SelfT: ...

    @overload
    def __add__(self: _SelfT, other: timedelta) -> _SelfT: ...

    @overload
    def __radd__(self: _SelfT, other: relativedelta) -> _SelfT: ...

    @overload
    def __radd__(self: _SelfT, other: timedelta) -> _SelfT: ...

    @overload
    def __rsub__(self: _SelfT, other: relativedelta) -> _SelfT: ...

    @overload
    def __rsub__(self: _SelfT, other: timedelta) -> _SelfT: ...

    def __sub__(self: _SelfT, other: relativedelta) -> _SelfT: ...

    def __neg__(self: _SelfT) -> _SelfT: ...

    def __mul__(self: _SelfT, other: SupportsFloat) -> _SelfT: ...

    def __rmul__(self: _SelfT, other: SupportsFloat) -> _SelfT: ...

    def __div__(self: _SelfT, other: SupportsFloat) -> _SelfT: ...

    def __truediv__(self: _SelfT, other: SupportsFloat) -> _SelfT: ...

    def __abs__(self: _SelfT) -> _SelfT: ...

    def __new__(cls: Type[_P], *args: Union[str, PurePath]) -> _P: ...

    def __truediv__(self: _P, key: Union[str, PurePath]) -> _P: ...

    def __rtruediv__(self: _P, key: Union[str, PurePath]) -> _P: ...

    def __div__(self: _P, key: Union[str, PurePath]) -> _P: ...

    def relative_to(self: _P, *other: Union[str, PurePath]) -> _P: ...

    def with_name(self: _P, name: str) -> _P: ...

    def with_suffix(self: _P, suffix: str) -> _P: ...

    def joinpath(self: _P, *other: Union[str, PurePath]) -> _P: ...

    @property
    def parents(self: _P) -> Sequence[_P]: ...

    @property
    def parent(self: _P) -> _P: ...

    def __new__(cls: Type[_P], *args: Union[str, PurePath], **kwargs: Any) -> _P: ...

    @classmethod
    def cwd(cls: Type[_P]) -> _P: ...

    def resolve(self: _P) -> _P: ...

    @classmethod
    def home(cls: Type[_P]) -> _P: ...

    def absolute(self: _P) -> _P: ...

    def expanduser(self: _P) -> _P: ...

    @overload
    def __init__(
        self: Redis[str],
        host: Text,
        port: int,
        db: int,
        password: Optional[Text],
        socket_timeout: Optional[float],
        socket_connect_timeout: Optional[float],
        socket_keepalive: Optional[bool],
        socket_keepalive_options: Optional[Mapping[str, Union[int, str]]],
        connection_pool: Optional[ConnectionPool],
        unix_socket_path: Optional[Text],
        encoding: Text,
        encoding_errors: Text,
        charset: Optional[Text],
        errors: Optional[Text],
        decode_responses: Literal[True],
        retry_on_timeout: bool = ...,
        ssl: bool = ...,
        ssl_keyfile: Optional[Text] = ...,
        ssl_certfile: Optional[Text] = ...,
        ssl_cert_reqs: Optional[Union[str, int]] = ...,
        ssl_ca_certs: Optional[Text] = ...,
        ssl_check_hostname: bool = ...,
        max_connections: Optional[int] = ...,
        single_connection_client: bool = ...,
        health_check_interval: float = ...,
        client_name: Optional[Text] = ...,
        username: Optional[Text] = ...,
    ) -> None: ...

    @overload
    def __init__(
        self: Redis[str],
        host: Text = ...,
        port: int = ...,
        db: int = ...,
        password: Optional[Text] = ...,
        socket_timeout: Optional[float] = ...,
        socket_connect_timeout: Optional[float] = ...,
        socket_keepalive: Optional[bool] = ...,
        socket_keepalive_options: Optional[Mapping[str, Union[int, str]]] = ...,
        connection_pool: Optional[ConnectionPool] = ...,
        unix_socket_path: Optional[Text] = ...,
        encoding: Text = ...,
        encoding_errors: Text = ...,
        charset: Optional[Text] = ...,
        errors: Optional[Text] = ...,
        *,
        decode_responses: Literal[True],
        retry_on_timeout: bool = ...,
        ssl: bool = ...,
        ssl_keyfile: Optional[Text] = ...,
        ssl_certfile: Optional[Text] = ...,
        ssl_cert_reqs: Optional[Union[str, int]] = ...,
        ssl_ca_certs: Optional[Text] = ...,
        ssl_check_hostname: bool = ...,
        max_connections: Optional[int] = ...,
        single_connection_client: bool = ...,
        health_check_interval: float = ...,
        client_name: Optional[Text] = ...,
        username: Optional[Text] = ...,
    ) -> None: ...

    @overload
    def __init__(
        self: Redis[bytes],
        host: Text = ...,
        port: int = ...,
        db: int = ...,
        password: Optional[Text] = ...,
        socket_timeout: Optional[float] = ...,
        socket_connect_timeout: Optional[float] = ...,
        socket_keepalive: Optional[bool] = ...,
        socket_keepalive_options: Optional[Mapping[str, Union[int, str]]] = ...,
        connection_pool: Optional[ConnectionPool] = ...,
        unix_socket_path: Optional[Text] = ...,
        encoding: Text = ...,
        encoding_errors: Text = ...,
        charset: Optional[Text] = ...,
        errors: Optional[Text] = ...,
        decode_responses: Literal[False] = ...,
        retry_on_timeout: bool = ...,
        ssl: bool = ...,
        ssl_keyfile: Optional[Text] = ...,
        ssl_certfile: Optional[Text] = ...,
        ssl_cert_reqs: Optional[Union[str, int]] = ...,
        ssl_ca_certs: Optional[Text] = ...,
        ssl_check_hostname: bool = ...,
        max_connections: Optional[int] = ...,
        single_connection_client: bool = ...,
        health_check_interval: float = ...,
        client_name: Optional[Text] = ...,
        username: Optional[Text] = ...,
    ) -> None: ...

    def reset(self: Markdown) -> Markdown: ...

    @overload
    def __init__(
        self: _patch[Union[MagicMock, AsyncMock]],
        getter: Callable[[], Any],
        attribute: str,
        *,
        spec: Optional[Any],
        create: bool,
        spec_set: Optional[Any],
        autospec: Optional[Any],
        new_callable: Optional[Any],
        kwargs: Mapping[str, Any],
    ) -> None: ...

    # This overload also covers the case, where new==DEFAULT. In this case, self is _patch[Any].
    # Ideally we'd be able to add an overload for it so that self is _patch[MagicMock],
    # but that's impossible with the current type system.
    @overload
    def __init__(
        self: _patch[_T],
        getter: Callable[[], Any],
        attribute: str,
        new: _T,
        spec: Optional[Any],
        create: bool,
        spec_set: Optional[Any],
        autospec: Optional[Any],
        new_callable: Optional[Any],
        kwargs: Mapping[str, Any],
    ) -> None: ...

    @overload
    def __init__(
        self: _patch[MagicMock],
        getter: Callable[[], Any],
        attribute: str,
        *,
        spec: Optional[Any],
        create: bool,
        spec_set: Optional[Any],
        autospec: Optional[Any],
        new_callable: Optional[Any],
        kwargs: Mapping[str, Any],
    ) -> None: ...

    @overload
    def __init__(
        self: _patch[_T],
        getter: Callable[[], Any],
        attribute: str,
        new: _T,
        spec: Optional[Any],
        create: bool,
        spec_set: Optional[Any],
        autospec: Optional[Any],
        new_callable: Optional[Any],
        kwargs: Mapping[str, Any],
    ) -> None: ...

    def __ge__(self: _T, other: _T) -> bool: ...

    def __gt__(self: _T, other: _T) -> bool: ...

    def __le__(self: _T, other: _T) -> bool: ...

    def __lt__(self: _T, other: _T) -> bool: ...

    def __add__(self: _T, other: int) -> _T: ...

    def __sub__(self: _T, other: int) -> _T: ...

    def address_exclude(self: _T, other: _T) -> Iterator[_T]: ...

    def compare_networks(self: _T, other: _T) -> int: ...

    def subnets(self: _T, prefixlen_diff: int = ..., new_prefix: Optional[int] = ...) -> Iterator[_T]: ...

    def supernet(self: _T, prefixlen_diff: int = ..., new_prefix: Optional[int] = ...) -> _T: ...

    def __reduce_ex__(self: _D, protocol) -> Tuple[Type[_D], List[_V]]: ...

    @classmethod
    def force_type(cls: Type[_SelfT], response: object, environ: Optional[WSGIEnvironment] = ...) -> _SelfT: ...

    @classmethod
    def from_app(cls: Type[_SelfT], app: Any, environ: WSGIEnvironment, buffered: bool = ...) -> _SelfT: ...

    def __enter__(self: _SessionT) -> _SessionT: ...

    def __enter__(self: _T) -> _T: ...

    def copy(self: _T) -> _T: ...

    def update(self: _T, __m: _T) -> None: ...

    @classmethod
    def add_representer(cls: Type[_R], data_type: Type[_T], representer: Callable[[_R, _T], Node]) -> None: ...

    @classmethod
    def add_multi_representer(cls: Type[_R], data_type: Type[_T], representer: Callable[[_R, _T], Node]) -> None: ...

    def MergeFrom(self: _M, other_msg: _M) -> None: ...

    def CopyFrom(self: _M, other_msg: _M) -> None: ...

    # Dummy fallback overloads with FieldDescriptor are for backward compatibility with
    # mypy-protobuf <= 1.23. We can drop them a few months after 1.24 releases.
    @overload
    def HasExtension(self: _M, extension_handle: _ExtensionFieldDescriptor[_M, Any]) -> bool: ...

    @overload
    def ClearExtension(self: _M, extension_handle: _ExtensionFieldDescriptor[_M, Any]) -> None: ...

    @classmethod
    def FromString(cls: Type[_M], s: _Serialized) -> _M: ...

    @property
    def Extensions(self: _M) -> _ExtensionDict[_M]: ...

    def MergeFrom(self: _M, other: _M) -> None: ...

    def MergeFrom(self: _M, other: _M) -> None: ...

    def MergeFrom(self: _M, other: _M): ...

    def MergeFrom(self: _M, other: _M): ...

    def __iter__(self: _SelfT) -> _SelfT: ...

    def run(self: _SelfT, cmd: str) -> _SelfT: ...

    def runctx(self: _SelfT, cmd: str, globals: Dict[str, Any], locals: Dict[str, Any]) -> _SelfT: ...

    def __enter__(self: _T) -> _T: ...

    @classmethod
    # We use Type and not Type[_S] to not lose the type inference from __iterable
    def from_iterable(cls: Type[Any], __iterable: Iterable[Iterable[_S]]) -> Iterator[_S]: ...

    def __new__(cls: Type[_P], *args: StrPath) -> _P: ...

    def __truediv__(self: _P, key: StrPath) -> _P: ...

    def __rtruediv__(self: _P, key: StrPath) -> _P: ...

    def relative_to(self: _P, *other: StrPath) -> _P: ...

    def with_name(self: _P, name: str) -> _P: ...

    def with_stem(self: _P, stem: str) -> _P: ...

    def with_suffix(self: _P, suffix: str) -> _P: ...

    def joinpath(self: _P, *other: StrPath) -> _P: ...

    @property
    def parents(self: _P) -> Sequence[_P]: ...

    @property
    def parent(self: _P) -> _P: ...

    def __new__(cls: Type[_P], *args: StrPath, **kwargs: Any) -> _P: ...

    def __enter__(self: _P) -> _P: ...

    @classmethod
    def cwd(cls: Type[_P]) -> _P: ...

    def glob(self: _P, pattern: str) -> Generator[_P, None, None]: ...

    def iterdir(self: _P) -> Generator[_P, None, None]: ...

    def readlink(self: _P) -> _P: ...

    def rename(self: _P, target: Union[str, PurePath]) -> _P: ...

    def replace(self: _P, target: Union[str, PurePath]) -> _P: ...

    def resolve(self: _P, strict: bool = ...) -> _P: ...

    def rglob(self: _P, pattern: str) -> Generator[_P, None, None]: ...

    @classmethod
    def home(cls: Type[_P]) -> _P: ...

    def absolute(self: _P) -> _P: ...

    def expanduser(self: _P) -> _P: ...

    def __enter__(self: _T) -> _T: ...

    def dup(self: _T) -> _T: ...  # noqa: F811

    def __enter__(self: _T) -> _T: ...

    def __ge__(self: _T, other: _T) -> bool: ...

    def __gt__(self: _T, other: _T) -> bool: ...

    def __le__(self: _T, other: _T) -> bool: ...

    def __lt__(self: _T, other: _T) -> bool: ...

    def __add__(self: _T, other: int) -> _T: ...

    def __sub__(self: _T, other: int) -> _T: ...

    def address_exclude(self: _T, other: _T) -> Iterator[_T]: ...

    def compare_networks(self: _T, other: _T) -> int: ...

    def subnet_of(self: _T, other: _T) -> bool: ...

    def supernet_of(self: _T, other: _T) -> bool: ...

    def subnets(self: _T, prefixlen_diff: int = ..., new_prefix: Optional[int] = ...) -> Iterator[_T]: ...

    def supernet(self: _T, prefixlen_diff: int = ..., new_prefix: Optional[int] = ...) -> _T: ...

    def run(self: _SelfT, cmd: str) -> _SelfT: ...

    def runctx(self: _SelfT, cmd: str, globals: Dict[str, Any], locals: Dict[str, Any]) -> _SelfT: ...

    def __enter__(self: _SelfT) -> _SelfT: ...

    @classmethod
    def from_samples(cls: Type[_T], data: Iterable[SupportsFloat]) -> _T: ...

    @property
    def __class__(self: _T) -> Type[_T]: ...

    def __new__(cls: Type[_T], *args: Any, **kwargs: Any) -> _T: ...

    def __new__(cls: Type[_T], *args: Any, **kwargs: Any) -> _T: ...

    @overload
    def __new__(cls: Type[_TT], name: str, bases: Tuple[type, ...], namespace: Dict[str, Any], **kwds: Any) -> _TT: ...

    def __subclasses__(self: _TT) -> List[_TT]: ...

    @overload
    def __new__(cls: Type[_T], x: Union[str, bytes, SupportsInt, SupportsIndex, _SupportsTrunc] = ...) -> _T: ...

    @overload
    def __new__(cls: Type[_T], x: Union[str, bytes, bytearray], base: int) -> _T: ...

    def __new__(cls: Type[_T], x: Union[SupportsFloat, SupportsIndex, str, bytes, bytearray] = ...) -> _T: ...

    @overload
    def __new__(cls: Type[_T], real: float = ..., imag: float = ...) -> _T: ...

    @overload
    def __new__(cls: Type[_T], real: Union[str, SupportsComplex, SupportsIndex, complex]) -> _T: ...

    @overload
    def __new__(cls: Type[_T], o: object = ...) -> _T: ...

    @overload
    def __new__(cls: Type[_T], o: bytes, encoding: str = ..., errors: str = ...) -> _T: ...

    @overload
    def __new__(cls: Type[_T], ints: Iterable[int]) -> _T: ...

    @overload
    def __new__(cls: Type[_T], string: str, encoding: str, errors: str = ...) -> _T: ...

    @overload
    def __new__(cls: Type[_T], length: int) -> _T: ...

    @overload
    def __new__(cls: Type[_T]) -> _T: ...

    @overload
    def __new__(cls: Type[_T], o: SupportsBytes) -> _T: ...

    def __new__(cls: Type[_T], __o: object = ...) -> _T: ...

    def __new__(cls: Type[_T], iterable: Iterable[_T_co] = ...) -> _T: ...

    @overload
    def sort(self: List[SupportsLessThanT], *, key: None = ..., reverse: bool = ...) -> None: ...

    def __iadd__(self: _S, x: Iterable[_T]) -> _S: ...

    def __imul__(self: _S, n: int) -> _S: ...

    @overload
    def __init__(self: Dict[_KT, _VT]) -> None: ...

    @overload
    def __init__(self: Dict[str, _VT], **kwargs: _VT) -> None: ...

    def __new__(cls: Type[_T1], *args: Any, **kwargs: Any) -> _T1: ...

    def with_traceback(self: _TBE, tb: Optional[TracebackType]) -> _TBE: ...

    def __init__(
        self: _T,
        __arg: Union[None, str, Profile, _cProfile] = ...,
        *args: Union[None, str, Profile, _cProfile, _T],
        stream: Optional[IO[Any]] = ...,
    ) -> None: ...

    def add(self: _T, *arg_list: Union[None, str, Profile, _cProfile, _T]) -> _T: ...

    @overload
    def sort_stats(self: _T, field: int) -> _T: ...

    @overload
    def sort_stats(self: _T, *field: str) -> _T: ...

    def reverse_order(self: _T) -> _T: ...

    def strip_dirs(self: _T) -> _T: ...

    def print_stats(self: _T, *amount: _Selector) -> _T: ...

    def print_callees(self: _T, *amount: _Selector) -> _T: ...

    def print_callers(self: _T, *amount: _Selector) -> _T: ...

    def __new__(cls: Type[_DecimalT], value: _DecimalNew = ..., context: Optional[Context] = ...) -> _DecimalT: ...

    @overload
    def __init__(
        self: DictReader[str],
        f: Iterable[str],
        fieldnames: Optional[Sequence[str]] = ...,
        restkey: Optional[str] = ...,
        restval: Optional[str] = ...,
        dialect: _DialectLike = ...,
        *args: Any,
        **kwds: Any,
    ) -> None: ...

    @overload
    def __new__(
        cls: Type[_T],
        numerator: Union[int, Rational] = ...,
        denominator: Optional[Union[int, Rational]] = ...,
        *,
        _normalize: bool = ...,
    ) -> _T: ...

    @overload
    def __new__(cls: Type[_T], __value: Union[float, Decimal, str], *, _normalize: bool = ...) -> _T: ...

    def copy(self: _T) -> _T: ...

    def update(self: _T, __m: _T) -> None: ...

    def __enter__(self: _T) -> _T: ...

    def __enter__(self: _T) -> _T: ...

    def __enter__(self: _T) -> _T: ...

    def pop_all(self: _U) -> _U: ...

    def __enter__(self: _U) -> _U: ...

    def pop_all(self: _S) -> _S: ...

    def __aenter__(self: _S) -> Awaitable[_S]: ...

    def __enter__(self: _SW) -> _SW: ...

    def __enter__(self: _SR) -> _SR: ...

    def __iter__(self: _T) -> _T: ...

    def __enter__(self: _T) -> _T: ...

    def __iter__(self: _SRT) -> _SRT: ...

    def __enter__(self: _SRT) -> _SRT: ...

    def __enter__(self: _T) -> _T: ...

    @classmethod
    def _make(cls: Type[_T], iterable: Iterable[Any]) -> _T: ...

    def _replace(self: _T, **kwargs: Any) -> _T: ...

    def copy(self: _T) -> _T: ...

    def update(self: _T, __m: _T) -> None: ...

    def __or__(self: _T, __value: _T) -> _T: ...

    def __ior__(self: _T, __value: _T) -> _T: ...

    def __enter__(self: _T) -> _T: ...

    def clone(self: _T) -> _T: ...

    def getturtle(self: _T) -> _T: ...

    def __iter__(self: _SLT) -> _SLT: ...

    def __new__(cls: Type[_S], year: int, month: int, day: int) -> _S: ...

    @classmethod
    def fromtimestamp(cls: Type[_S], __timestamp: float) -> _S: ...

    @classmethod
    def today(cls: Type[_S]) -> _S: ...

    @classmethod
    def fromordinal(cls: Type[_S], n: int) -> _S: ...

    @classmethod
    def fromisoformat(cls: Type[_S], date_string: str) -> _S: ...

    @classmethod
    def fromisocalendar(cls: Type[_S], year: int, week: int, day: int) -> _S: ...

    def __add__(self: _S, other: timedelta) -> _S: ...

    def __radd__(self: _S, other: timedelta) -> _S: ...

    def __new__(
        cls: Type[_S],
        hour: int = ...,
        minute: int = ...,
        second: int = ...,
        microsecond: int = ...,
        tzinfo: Optional[_tzinfo] = ...,
        *,
        fold: int = ...,
    ) -> _S: ...

    @classmethod
    def fromisoformat(cls: Type[_S], time_string: str) -> _S: ...

    def __new__(
        cls: Type[_S],
        days: float = ...,
        seconds: float = ...,
        microseconds: float = ...,
        milliseconds: float = ...,
        minutes: float = ...,
        hours: float = ...,
        weeks: float = ...,
    ) -> _S: ...

    def __new__(
        cls: Type[_S],
        year: int,
        month: int,
        day: int,
        hour: int = ...,
        minute: int = ...,
        second: int = ...,
        microsecond: int = ...,
        tzinfo: Optional[_tzinfo] = ...,
        *,
        fold: int = ...,
    ) -> _S: ...

    @classmethod
    def fromtimestamp(cls: Type[_S], t: float, tz: Optional[_tzinfo] = ...) -> _S: ...

    @classmethod
    def utcfromtimestamp(cls: Type[_S], t: float) -> _S: ...

    @classmethod
    def today(cls: Type[_S]) -> _S: ...

    @classmethod
    def fromordinal(cls: Type[_S], n: int) -> _S: ...

    @classmethod
    def now(cls: Type[_S], tz: Optional[_tzinfo] = ...) -> _S: ...

    @overload
    @classmethod
    def now(cls: Type[_S], tz: None = ...) -> _S: ...

    @classmethod
    def utcnow(cls: Type[_S]) -> _S: ...

    @classmethod
    def fromisoformat(cls: Type[_S], date_string: str) -> _S: ...

    def astimezone(self: _S, tz: Optional[_tzinfo] = ...) -> _S: ...

    def __add__(self: _S, other: timedelta) -> _S: ...

    def __radd__(self: _S, other: timedelta) -> _S: ...

    def copy(self: _SelfT) -> _SelfT: ...

    def difference(self: _SelfT, other: Iterable[_T]) -> _SelfT: ...

    def __sub__(self: _SelfT, other: Iterable[_T]) -> _SelfT: ...

    def __isub__(self: _SelfT, other: Iterable[_T]) -> _SelfT: ...

    def intersection(self: _SelfT, other: Iterable[_T]) -> _SelfT: ...

    def __and__(self: _SelfT, other: Iterable[_T]) -> _SelfT: ...

    def __iand__(self: _SelfT, other: Iterable[_T]) -> _SelfT: ...

    def register(cls: ABCMeta, subclass: Type[_T]) -> Type[_T]: ...

    def __enter__(self: _TF) -> _TF: ...

    @classmethod
    def open(
        cls: Type[_TF],
        name: Optional[StrOrBytesPath] = ...,
        mode: str = ...,
        fileobj: Optional[IO[bytes]] = ...,  # depends on mode
        bufsize: int = ...,
        *,
        format: Optional[int] = ...,
        tarinfo: Optional[Type[TarInfo]] = ...,
        dereference: Optional[bool] = ...,
        ignore_zeros: Optional[bool] = ...,
        encoding: Optional[str] = ...,
        errors: str = ...,
        pax_headers: Optional[Mapping[str, str]] = ...,
        debug: Optional[int] = ...,
        errorlevel: Optional[int] = ...,
    ) -> _TF: ...

    @classmethod
    def taropen(
        cls: Type[_TF],
        name: Optional[StrOrBytesPath],
        mode: Literal["r", "a", "w", "x"] = ...,
        fileobj: Optional[_Fileobj] = ...,
        *,
        compresslevel: int = ...,
        format: Optional[int] = ...,
        tarinfo: Optional[Type[TarInfo]] = ...,
        dereference: Optional[bool] = ...,
        ignore_zeros: Optional[bool] = ...,
        encoding: Optional[str] = ...,
        pax_headers: Optional[Mapping[str, str]] = ...,
        debug: Optional[int] = ...,
        errorlevel: Optional[int] = ...,
    ) -> _TF: ...

    @overload
    @classmethod
    def gzopen(
        cls: Type[_TF],
        name: Optional[StrOrBytesPath],
        mode: Literal["r"] = ...,
        fileobj: Optional[_GzipReadableFileobj] = ...,
        compresslevel: int = ...,
        *,
        format: Optional[int] = ...,
        tarinfo: Optional[Type[TarInfo]] = ...,
        dereference: Optional[bool] = ...,
        ignore_zeros: Optional[bool] = ...,
        encoding: Optional[str] = ...,
        pax_headers: Optional[Mapping[str, str]] = ...,
        debug: Optional[int] = ...,
        errorlevel: Optional[int] = ...,
    ) -> _TF: ...

    @overload
    @classmethod
    def gzopen(
        cls: Type[_TF],
        name: Optional[StrOrBytesPath],
        mode: Literal["w", "x"],
        fileobj: Optional[_GzipWritableFileobj] = ...,
        compresslevel: int = ...,
        *,
        format: Optional[int] = ...,
        tarinfo: Optional[Type[TarInfo]] = ...,
        dereference: Optional[bool] = ...,
        ignore_zeros: Optional[bool] = ...,
        encoding: Optional[str] = ...,
        pax_headers: Optional[Mapping[str, str]] = ...,
        debug: Optional[int] = ...,
        errorlevel: Optional[int] = ...,
    ) -> _TF: ...

    @overload
    @classmethod
    def bz2open(
        cls: Type[_TF],
        name: Optional[StrOrBytesPath],
        mode: Literal["w", "x"],
        fileobj: Optional[_Bz2WritableFileobj] = ...,
        compresslevel: int = ...,
        *,
        format: Optional[int] = ...,
        tarinfo: Optional[Type[TarInfo]] = ...,
        dereference: Optional[bool] = ...,
        ignore_zeros: Optional[bool] = ...,
        encoding: Optional[str] = ...,
        pax_headers: Optional[Mapping[str, str]] = ...,
        debug: Optional[int] = ...,
        errorlevel: Optional[int] = ...,
    ) -> _TF: ...

    @overload
    @classmethod
    def bz2open(
        cls: Type[_TF],
        name: Optional[StrOrBytesPath],
        mode: Literal["r"] = ...,
        fileobj: Optional[_Bz2ReadableFileobj] = ...,
        compresslevel: int = ...,
        *,
        format: Optional[int] = ...,
        tarinfo: Optional[Type[TarInfo]] = ...,
        dereference: Optional[bool] = ...,
        ignore_zeros: Optional[bool] = ...,
        encoding: Optional[str] = ...,
        pax_headers: Optional[Mapping[str, str]] = ...,
        debug: Optional[int] = ...,
        errorlevel: Optional[int] = ...,
    ) -> _TF: ...

    @classmethod
    def xzopen(
        cls: Type[_TF],
        name: Optional[StrOrBytesPath],
        mode: Literal["r", "w", "x"] = ...,
        fileobj: Optional[IO[bytes]] = ...,
        preset: Optional[int] = ...,
        *,
        format: Optional[int] = ...,
        tarinfo: Optional[Type[TarInfo]] = ...,
        dereference: Optional[bool] = ...,
        ignore_zeros: Optional[bool] = ...,
        encoding: Optional[str] = ...,
        pax_headers: Optional[Mapping[str, str]] = ...,
        debug: Optional[int] = ...,
        errorlevel: Optional[int] = ...,
    ) -> _TF: ...

    def __enter__(self: _S) -> _S: ...

    @overload
    def __init__(
        self: SpooledTemporaryFile[bytes],
        max_size: int = ...,
        mode: Literal["rb", "wb", "ab", "xb", "r+b", "w+b", "a+b", "x+b"] = ...,
        buffering: int = ...,
        encoding: Optional[str] = ...,
        newline: Optional[str] = ...,
        suffix: Optional[str] = ...,
        prefix: Optional[str] = ...,
        dir: Optional[str] = ...,
        *,
        errors: Optional[str] = ...,
    ) -> None: ...

    @overload
    def __init__(
        self: SpooledTemporaryFile[str],
        max_size: int = ...,
        mode: Literal["r", "w", "a", "x", "r+", "w+", "a+", "x+", "rt", "wt", "at", "xt", "r+t", "w+t", "a+t", "x+t"] = ...,
        buffering: int = ...,
        encoding: Optional[str] = ...,
        newline: Optional[str] = ...,
        suffix: Optional[str] = ...,
        prefix: Optional[str] = ...,
        dir: Optional[str] = ...,
        *,
        errors: Optional[str] = ...,
    ) -> None: ...

    @overload
    def __init__(
        self: SpooledTemporaryFile[bytes],
        max_size: int = ...,
        mode: Literal["rb", "wb", "ab", "xb", "r+b", "w+b", "a+b", "x+b"] = ...,
        buffering: int = ...,
        encoding: Optional[str] = ...,
        newline: Optional[str] = ...,
        suffix: Optional[str] = ...,
        prefix: Optional[str] = ...,
        dir: Optional[str] = ...,
    ) -> None: ...

    @overload
    def __init__(
        self: SpooledTemporaryFile[str],
        max_size: int = ...,
        mode: Literal["r", "w", "a", "x", "r+", "w+", "a+", "x+", "rt", "wt", "at", "xt", "r+t", "w+t", "a+t", "x+t"] = ...,
        buffering: int = ...,
        encoding: Optional[str] = ...,
        newline: Optional[str] = ...,
        suffix: Optional[str] = ...,
        prefix: Optional[str] = ...,
        dir: Optional[str] = ...,
    ) -> None: ...

    def __enter__(self: _S) -> _S: ...

    @overload
    def __init__(self: TemporaryDirectory[str], suffix: None = ..., prefix: None = ..., dir: None = ...) -> None: ...

    def __enter__(self: _SelfT) -> _SelfT: ...

    @overload
    def __init__(self: array[int], typecode: _IntTypeCode, __initializer: Union[bytes, Iterable[_T]] = ...) -> None: ...

    @overload
    def __init__(self: array[float], typecode: _FloatTypeCode, __initializer: Union[bytes, Iterable[_T]] = ...) -> None: ...

    @overload
    def __init__(self: array[str], typecode: _UnicodeTypeCode, __initializer: Union[bytes, Iterable[_T]] = ...) -> None: ...

    def __enter__(self: _T) -> _T: ...

    def __enter__(self: _T) -> _T: ...

    def __enter__(self: _T) -> _T: ...

    def __enter__(self: _T) -> _T: ...

    def __enter__(self: _T) -> _T: ...

    def __enter__(self: _T) -> _T: ...

    # These are inherited from TextIOBase, but must exist in the stub to satisfy mypy.
    def __enter__(self: _T) -> _T: ...

    def __iter__(self: Type[_T]) -> Iterator[_T]: ...

    def __reversed__(self: Type[_T]) -> Iterator[_T]: ...

    def __contains__(self: Type[Any], member: object) -> bool: ...

    def __getitem__(self: Type[_T], name: str) -> _T: ...

    @_builtins_property
    def __members__(self: Type[_T]) -> Mapping[str, _T]: ...

    def __new__(cls: Type[_T], value: object) -> _T: ...

    def __new__(cls: Type[_T], value: Union[int, _T]) -> _T: ...

    def __new__(cls: Type[_T]) -> _T: ...

    def __contains__(self: _T, other: _T) -> bool: ...

    def __or__(self: _T, other: _T) -> _T: ...

    def __and__(self: _T, other: _T) -> _T: ...

    def __xor__(self: _T, other: _T) -> _T: ...

    def __invert__(self: _T) -> _T: ...

    def __new__(cls: Type[_T], value: Union[int, _T]) -> _T: ...

    def __or__(self: _T, other: Union[int, _T]) -> _T: ...

    def __and__(self: _T, other: Union[int, _T]) -> _T: ...

    def __xor__(self: _T, other: Union[int, _T]) -> _T: ...

    def __new__(cls: Type[_T], value: Union[int, _T]) -> _T: ...

    def __lt__(self: _T, other: Union[_T, str]) -> bool: ...

    def __le__(self: _T, other: Union[_T, str]) -> bool: ...

    def __gt__(self: _T, other: Union[_T, str]) -> bool: ...

    def __ge__(self: _T, other: Union[_T, str]) -> bool: ...

    @abstractmethod
    def parse(self: _T, vstring: str) -> _T: ...

    @abstractmethod
    def _cmp(self: _T, other: Union[_T, str]) -> bool: ...

    def parse(self: _T, vstring: str) -> _T: ...

    def _cmp(self: _T, other: Union[_T, str]) -> bool: ...

    def parse(self: _T, vstring: str) -> _T: ...

    def _cmp(self: _T, other: Union[_T, str]) -> bool: ...

    @classmethod
    def no_cache(cls: Type[_T], key: str) -> _T: ...

    @classmethod
    def from_file(cls: Type[_T], __fobj: _IOBytes, key: Optional[str] = ...) -> _T: ...

    # By default mypy complains about the following two methods, because strictly speaking cls
    # might not be a Type[_CT]. However this can never actually happen, because the only class that
    # uses _CDataMeta as its metaclass is _CData. So it's safe to ignore the errors here.
    def __mul__(cls: Type[_CT], other: int) -> Type[Array[_CT]]: ...  # type: ignore

    def __rmul__(cls: Type[_CT], other: int) -> Type[Array[_CT]]: ...  # type: ignore

    @classmethod
    def from_buffer(cls: Type[_CT], source: _WritableBuffer, offset: int = ...) -> _CT: ...

    @classmethod
    def from_buffer_copy(cls: Type[_CT], source: _ReadOnlyBuffer, offset: int = ...) -> _CT: ...

    @classmethod
    def from_address(cls: Type[_CT], address: int) -> _CT: ...

    @classmethod
    def from_param(cls: Type[_CT], obj: Any) -> _UnionT[_CT, _CArgObject]: ...

    @classmethod
    def in_dll(cls: Type[_CT], library: CDLL, name: str) -> _CT: ...

    def run(self: _SelfT, cmd: str) -> _SelfT: ...

    def runctx(self: _SelfT, cmd: str, globals: Dict[str, Any], locals: Dict[str, Any]) -> _SelfT: ...

    def run(self: _SelfT, cmd: str) -> _SelfT: ...

    def runctx(self: _SelfT, cmd: str, globals: Dict[str, Any], locals: Dict[str, Any]) -> _SelfT: ...

    def __enter__(self: _T) -> _T: ...

    def __iter__(self: _T) -> _T: ...

    def __enter__(self: _T) -> _T: ...

    def __iter__(self: _T) -> _T: ...

    @property
    def __class__(self: _T) -> Type[_T]: ...

    def __new__(cls: Type[_T], *args: Any, **kwargs: Any) -> _T: ...

    def __new__(cls: Type[_T], *args: Any, **kwargs: Any) -> _T: ...

    def __subclasses__(self: _TT) -> List[_TT]: ...

    @overload
    def __new__(cls: Type[_T], x: Union[Text, bytes, SupportsInt, _SupportsIndex, _SupportsTrunc] = ...) -> _T: ...

    @overload
    def __new__(cls: Type[_T], x: Union[Text, bytes, bytearray], base: int) -> _T: ...

    def __new__(cls: Type[_T], x: Union[SupportsFloat, _SupportsIndex, Text, bytes, bytearray] = ...) -> _T: ...

    @overload
    def __new__(cls: Type[_T], real: float = ..., imag: float = ...) -> _T: ...

    @overload
    def __new__(cls: Type[_T], real: Union[str, SupportsComplex, _SupportsIndex]) -> _T: ...

    def __new__(cls: Type[_T], __o: object = ...) -> _T: ...

    def __new__(cls: Type[_T], iterable: Iterable[_T_co] = ...) -> _T: ...

    def __iadd__(self: _S, x: Iterable[_T]) -> _S: ...

    def __new__(cls: Type[_T1], *args: Any, **kwargs: Any) -> _T1: ...

    @overload
    def __sub__(self: Set[str], s: AbstractSet[Optional[Text]]) -> Set[_T]: ...

    @overload  # type: ignore
    def __isub__(self: Set[str], s: AbstractSet[Optional[Text]]) -> Set[_T]: ...

    @overload
    def __getitem__(self: _S, s: slice) -> _S: ...

    def __init__(
        self: _T,
        __arg: Union[None, str, Text, Profile, _cProfile] = ...,
        *args: Union[None, str, Text, Profile, _cProfile, _T],
        stream: Optional[IO[Any]] = ...,
    ) -> None: ...

    def add(self: _T, *arg_list: Union[None, str, Text, Profile, _cProfile, _T]) -> _T: ...

    @overload
    def sort_stats(self: _T, field: int) -> _T: ...

    @overload
    def sort_stats(self: _T, *field: str) -> _T: ...

    def reverse_order(self: _T) -> _T: ...

    def strip_dirs(self: _T) -> _T: ...

    def print_stats(self: _T, *amount: _Selector) -> _T: ...

    def print_callees(self: _T, *amount: _Selector) -> _T: ...

    def print_callers(self: _T, *amount: _Selector) -> _T: ...

    @overload
    def __getitem__(self: _UST, i: int) -> _UST: ...

    @overload
    def __getitem__(self: _UST, s: slice) -> _UST: ...

    def __add__(self: _UST, other: Any) -> _UST: ...

    def __radd__(self: _UST, other: Any) -> _UST: ...

    def __mul__(self: _UST, other: int) -> _UST: ...

    def __rmul__(self: _UST, other: int) -> _UST: ...

    def __mod__(self: _UST, args: Any) -> _UST: ...

    def capitalize(self: _UST) -> _UST: ...

    def center(self: _UST, width: int, *args: Any) -> _UST: ...

    def decode(self: _UST, encoding: Optional[str] = ..., errors: Optional[str] = ...) -> _UST: ...

    def encode(self: _UST, encoding: Optional[str] = ..., errors: Optional[str] = ...) -> _UST: ...

    def expandtabs(self: _UST, tabsize: int = ...) -> _UST: ...

    def ljust(self: _UST, width: int, *args: Any) -> _UST: ...

    def lower(self: _UST) -> _UST: ...

    def lstrip(self: _UST, chars: Optional[Text] = ...) -> _UST: ...

    def replace(self: _UST, old: Text, new: Text, maxsplit: int = ...) -> _UST: ...

    def rjust(self: _UST, width: int, *args: Any) -> _UST: ...

    def rstrip(self: _UST, chars: Optional[Text] = ...) -> _UST: ...

    def strip(self: _UST, chars: Optional[Text] = ...) -> _UST: ...

    def swapcase(self: _UST) -> _UST: ...

    def title(self: _UST) -> _UST: ...

    def translate(self: _UST, *args: Any) -> _UST: ...

    def upper(self: _UST) -> _UST: ...

    def zfill(self: _UST, width: int) -> _UST: ...

    @overload
    def __getitem__(self: _MST, i: int) -> _MST: ...

    @overload
    def __getitem__(self: _MST, s: slice) -> _MST: ...

    def __iadd__(self: _MST, other: Any) -> _MST: ...

    def __new__(cls: Type[_DecimalT], value: _DecimalNew = ..., context: Optional[Context] = ...) -> _DecimalT: ...

    @overload
    def __init__(
        self: DictReader[str],
        f: Iterable[Text],
        fieldnames: Optional[Sequence[str]] = ...,
        restkey: Optional[str] = ...,
        restval: Optional[str] = ...,
        dialect: _DialectLike = ...,
        *args: Any,
        **kwds: Any,
    ) -> None: ...

    @overload
    def __new__(
        cls: Type[_T],
        numerator: Union[int, Rational] = ...,
        denominator: Optional[Union[int, Rational]] = ...,
        *,
        _normalize: bool = ...,
    ) -> _T: ...

    @overload
    def __new__(cls: Type[_T], __value: Union[float, Decimal, str], *, _normalize: bool = ...) -> _T: ...

    def copy(self: _T) -> _T: ...

    def update(self: _T, __m: _T) -> None: ...

    def __iadd__(self: _S, iterable: Iterable[_T]) -> _S: ...

    def copy(self: _S) -> _S: ...

    def copy(self: _S) -> _S: ...

    def copy(self: _S) -> _S: ...

    @property
    def __class__(self: _T) -> Type[_T]: ...

    def __new__(cls: Type[_T], *args: Any, **kwargs: Any) -> _T: ...

    def __new__(cls: Type[_T], *args: Any, **kwargs: Any) -> _T: ...

    def __subclasses__(self: _TT) -> List[_TT]: ...

    @overload
    def __new__(cls: Type[_T], x: Union[Text, bytes, SupportsInt, _SupportsIndex, _SupportsTrunc] = ...) -> _T: ...

    @overload
    def __new__(cls: Type[_T], x: Union[Text, bytes, bytearray], base: int) -> _T: ...

    def __new__(cls: Type[_T], x: Union[SupportsFloat, _SupportsIndex, Text, bytes, bytearray] = ...) -> _T: ...

    @overload
    def __new__(cls: Type[_T], real: float = ..., imag: float = ...) -> _T: ...

    @overload
    def __new__(cls: Type[_T], real: Union[str, SupportsComplex, _SupportsIndex]) -> _T: ...

    def __new__(cls: Type[_T], __o: object = ...) -> _T: ...

    def __new__(cls: Type[_T], iterable: Iterable[_T_co] = ...) -> _T: ...

    def __iadd__(self: _S, x: Iterable[_T]) -> _S: ...

    def __new__(cls: Type[_T1], *args: Any, **kwargs: Any) -> _T1: ...

    @overload
    def __sub__(self: Set[str], s: AbstractSet[Optional[Text]]) -> Set[_T]: ...

    @overload  # type: ignore
    def __isub__(self: Set[str], s: AbstractSet[Optional[Text]]) -> Set[_T]: ...

    def __enter__(self: _SW) -> _SW: ...

    def __enter__(self: _SR) -> _SR: ...

    def __iter__(self: _T) -> _T: ...

    def __enter__(self: _T) -> _T: ...

    def __iter__(self: _SRT) -> _SRT: ...

    def __enter__(self: _SRT) -> _SRT: ...

    def __enter__(self: _T) -> _T: ...

    @classmethod
    def _make(cls: Type[_T], iterable: Iterable[Any]) -> _T: ...

    def _replace(self: _T, **kwargs: Any) -> _T: ...

    def copy(self: _T) -> _T: ...

    def update(self: _T, __m: _T) -> None: ...

    def __iter__(self: _AIUT) -> _AIUT: ...

    def clone(self: _T) -> _T: ...

    def getturtle(self: _T) -> _T: ...

    def __iter__(self: _SLT) -> _SLT: ...

    def copy(self: _SelfT) -> _SelfT: ...

    def __copy__(self: _SelfT) -> _SelfT: ...

    def __deepcopy__(self: _SelfT, memo: MutableMapping[int, BaseSet[_T]]) -> _SelfT: ...

    def __or__(self: _SelfT, other: BaseSet[_T]) -> _SelfT: ...

    def union(self: _SelfT, other: _Setlike[_T]) -> _SelfT: ...

    def __and__(self: _SelfT, other: BaseSet[_T]) -> _SelfT: ...

    def intersection(self: _SelfT, other: _Setlike[Any]) -> _SelfT: ...

    def __xor__(self: _SelfT, other: BaseSet[_T]) -> _SelfT: ...

    def symmetric_difference(self: _SelfT, other: _Setlike[_T]) -> _SelfT: ...

    def __sub__(self: _SelfT, other: BaseSet[_T]) -> _SelfT: ...

    def difference(self: _SelfT, other: _Setlike[Any]) -> _SelfT: ...

    def __ior__(self: _SelfT, other: BaseSet[_T]) -> _SelfT: ...

    def __iand__(self: _SelfT, other: BaseSet[_T]) -> _SelfT: ...

    def __ixor__(self: _SelfT, other: BaseSet[_T]) -> _SelfT: ...

    def __isub__(self: _SelfT, other: BaseSet[_T]) -> _SelfT: ...

    def __new__(cls: Type[_S], year: int, month: int, day: int) -> _S: ...

    @classmethod
    def fromtimestamp(cls: Type[_S], __timestamp: float) -> _S: ...

    @classmethod
    def today(cls: Type[_S]) -> _S: ...

    @classmethod
    def fromordinal(cls: Type[_S], n: int) -> _S: ...

    def __new__(
        cls: Type[_S],
        hour: int = ...,
        minute: int = ...,
        second: int = ...,
        microsecond: int = ...,
        tzinfo: Optional[_tzinfo] = ...,
    ) -> _S: ...

    def __new__(
        cls: Type[_S],
        days: float = ...,
        seconds: float = ...,
        microseconds: float = ...,
        milliseconds: float = ...,
        minutes: float = ...,
        hours: float = ...,
        weeks: float = ...,
    ) -> _S: ...

    def __new__(
        cls: Type[_S],
        year: int,
        month: int,
        day: int,
        hour: int = ...,
        minute: int = ...,
        second: int = ...,
        microsecond: int = ...,
        tzinfo: Optional[_tzinfo] = ...,
    ) -> _S: ...

    @classmethod
    def fromtimestamp(cls: Type[_S], t: float, tz: Optional[_tzinfo] = ...) -> _S: ...

    @classmethod
    def utcfromtimestamp(cls: Type[_S], t: float) -> _S: ...

    @classmethod
    def today(cls: Type[_S]) -> _S: ...

    @classmethod
    def fromordinal(cls: Type[_S], n: int) -> _S: ...

    @overload
    @classmethod
    def now(cls: Type[_S], tz: None = ...) -> _S: ...

    @classmethod
    def utcnow(cls: Type[_S]) -> _S: ...

    def copy(self: _SelfT) -> _SelfT: ...

    def difference(self: _SelfT, other: Iterable[_T]) -> _SelfT: ...

    def __sub__(self: _SelfT, other: Iterable[_T]) -> _SelfT: ...

    def __isub__(self: _SelfT, other: Iterable[_T]) -> _SelfT: ...

    def intersection(self: _SelfT, other: Iterable[_T]) -> _SelfT: ...

    def __and__(self: _SelfT, other: Iterable[_T]) -> _SelfT: ...

    def __iand__(self: _SelfT, other: Iterable[_T]) -> _SelfT: ...

    def __instancecheck__(cls: ABCMeta, instance: Any) -> Any: ...

    def __subclasscheck__(cls: ABCMeta, subclass: Any) -> Any: ...

    def _dump_registry(cls: ABCMeta, *args: Any, **kwargs: Any) -> None: ...

    def register(cls: ABCMeta, subclass: Type[Any]) -> None: ...

    def __copy__(self: _T) -> _T: ...

    def copy(self: _T) -> _T: ...

    def __enter__(self: _SelfT) -> _SelfT: ...

    @overload
    def __init__(self: array[int], typecode: _IntTypeCode, __initializer: Union[bytes, Iterable[_T]] = ...) -> None: ...

    @overload
    def __init__(self: array[float], typecode: _FloatTypeCode, __initializer: Union[bytes, Iterable[_T]] = ...) -> None: ...

    @overload
    def __init__(self: array[Text], typecode: _UnicodeTypeCode, __initializer: Union[bytes, Iterable[_T]] = ...) -> None: ...

    @abstractmethod
    def parse(self: _T, vstring: Text) -> _T: ...

    @abstractmethod
    def __cmp__(self: _T, other: Union[_T, str]) -> bool: ...

    def parse(self: _T, vstring: Text) -> _T: ...

    def __cmp__(self: _T, other: Union[_T, str]) -> bool: ...

    def parse(self: _T, vstring: Text) -> _T: ...

    def __cmp__(self: _T, other: Union[_T, str]) -> bool: ...

    # By default mypy complains about the following two methods, because strictly speaking cls
    # might not be a Type[_CT]. However this can never actually happen, because the only class that
    # uses _CDataMeta as its metaclass is _CData. So it's safe to ignore the errors here.
    def __mul__(cls: Type[_CT], other: int) -> Type[Array[_CT]]: ...  # type: ignore

    def __rmul__(cls: Type[_CT], other: int) -> Type[Array[_CT]]: ...  # type: ignore

    @classmethod
    def from_buffer(cls: Type[_CT], source: _WritableBuffer, offset: int = ...) -> _CT: ...

    @classmethod
    def from_buffer_copy(cls: Type[_CT], source: _ReadOnlyBuffer, offset: int = ...) -> _CT: ...

    @classmethod
    def from_address(cls: Type[_CT], address: int) -> _CT: ...

    @classmethod
    def from_param(cls: Type[_CT], obj: Any) -> _UnionT[_CT, _CArgObject]: ...

    @classmethod
    def in_dll(cls: Type[_CT], library: CDLL, name: str) -> _CT: ...

    def __enter__(self: _T) -> _T: ...

    def _eq(self: _P, other: _P) -> bool: ...

    def clone(self: _P) -> _P: ...

    def copy(self: _P) -> _P: ...

    # If new==DEFAULT, self is _patch[Any]. Ideally we'd be able to add an overload for it so that self is _patch[MagicMock],
    # but that's impossible with the current type system.
    def __init__(
        self: _patch[_T],
        getter: Callable[[], Any],
        attribute: str,
        new: _T,
        spec: Optional[Any],
        create: bool,
        spec_set: Optional[Any],
        autospec: Optional[Any],
        new_callable: Optional[Any],
        kwargs: Mapping[str, Any],
    ) -> None: ...

    def __reduce__(self: _S) -> Tuple[_S, Tuple[_SLT, ...]]: ...

    def __iter__(self: _S) -> _S: ...

    def __enter__(self: _PT) -> _PT: ...

    def __enter__(self: _ConnectionT) -> _ConnectionT: ...

    def __enter__(self: _ListenerT) -> _ListenerT: ...

    def __enter__(self: _AIUT) -> _AIUT: ...

    def __iter__(self: _AIUT) -> _AIUT: ...

    # Allow bind callbacks to take e.g. Event[Label] instead of Event[Misc].
    # Tk and Toplevel get notified for their child widgets' events, but other
    # widgets don't.
    @overload
    def bind(
        self: _W, sequence: Optional[str] = ..., func: Optional[Callable[[Event[_W]], Any]] = ..., add: Optional[bool] = ...
    ) -> str: ...

    def __enter__(self: _T) -> _T: ...

    def __enter__(self: _T) -> _T: ...

    def __enter__(self: _T) -> _T: ...

    def _eq(self: _P, other: _P) -> bool: ...

    def clone(self: _P) -> _P: ...

    def copy(self: _P) -> _P: ...

    def copy(self: _S) -> _S: ...

    @classmethod
    def fromkeys(cls: Type[_S], iterable: Iterable[_KT], value: Optional[_VT] = ...) -> _S: ...

    def __add__(self: _S, other: Iterable[_T]) -> _S: ...

    def __iadd__(self: _S, other: Iterable[_T]) -> _S: ...

    def __mul__(self: _S, n: int) -> _S: ...

    def __imul__(self: _S, n: int) -> _S: ...

    def copy(self: _S) -> _S: ...

    # It should return a str to implement Sequence correctly, but it doesn't.
    def __getitem__(self: _UserStringT, i: Union[int, slice]) -> _UserStringT: ...  # type: ignore

    def __add__(self: _UserStringT, other: object) -> _UserStringT: ...

    def __mul__(self: _UserStringT, n: int) -> _UserStringT: ...

    def __mod__(self: _UserStringT, args: Any) -> _UserStringT: ...

    def capitalize(self: _UserStringT) -> _UserStringT: ...

    def casefold(self: _UserStringT) -> _UserStringT: ...

    def center(self: _UserStringT, width: int, *args: Any) -> _UserStringT: ...

    def encode(self: UserString, encoding: Optional[str] = ..., errors: Optional[str] = ...) -> bytes: ...

    def encode(self: _UserStringT, encoding: Optional[str] = ..., errors: Optional[str] = ...) -> _UserStringT: ...

    def expandtabs(self: _UserStringT, tabsize: int = ...) -> _UserStringT: ...

    def ljust(self: _UserStringT, width: int, *args: Any) -> _UserStringT: ...

    def lower(self: _UserStringT) -> _UserStringT: ...

    def lstrip(self: _UserStringT, chars: Optional[str] = ...) -> _UserStringT: ...

    def removeprefix(self: _UserStringT, __prefix: Union[str, UserString]) -> _UserStringT: ...

    def removesuffix(self: _UserStringT, __suffix: Union[str, UserString]) -> _UserStringT: ...

    def replace(
        self: _UserStringT, old: Union[str, UserString], new: Union[str, UserString], maxsplit: int = ...
    ) -> _UserStringT: ...

    def rjust(self: _UserStringT, width: int, *args: Any) -> _UserStringT: ...

    def rstrip(self: _UserStringT, chars: Optional[str] = ...) -> _UserStringT: ...

    def strip(self: _UserStringT, chars: Optional[str] = ...) -> _UserStringT: ...

    def swapcase(self: _UserStringT) -> _UserStringT: ...

    def title(self: _UserStringT) -> _UserStringT: ...

    def translate(self: _UserStringT, *args: Any) -> _UserStringT: ...

    def upper(self: _UserStringT) -> _UserStringT: ...

    def zfill(self: _UserStringT, width: int) -> _UserStringT: ...

    def __iadd__(self: _S, iterable: Iterable[_T]) -> _S: ...

    def copy(self: _S) -> _S: ...

    def copy(self: _S) -> _S: ...

    # TODO __reversed__
    def copy(self: _S) -> _S: ...

    def _callbacks(self: _S) -> List[Tuple[Callable[[_S], Any], Context]]: ...

    def add_done_callback(self: _S, __fn: Callable[[_S], Any], *, context: Optional[Context] = ...) -> None: ...

    @property
    def _callbacks(self: _S) -> List[Callable[[_S], Any]]: ...

    def add_done_callback(self: _S, __fn: Callable[[_S], Any]) -> None: ...

    def remove_done_callback(self: _S, __fn: Callable[[_S], Any]) -> int: ...

    def __enter__(self: _T1) -> _T1: ...

    def __enter__(self: _T2) -> _T2: ...

    def __enter__(self: _T3) -> _T3: ...

    def __enter__(self: _T4) -> _T4: ...

    def __enter__(self: _T5) -> _T5: ...

    async def __aenter__(self: _T) -> _T: ...

    def __new__(cls: Type[_T], value: str, token_type: str) -> _T: ...

    @overload
    def __init__(self: FeedParser[Message], _factory: None = ..., *, policy: Policy = ...) -> None: ...

    @overload
    def __init__(self: BytesFeedParser[Message], _factory: None = ..., *, policy: Policy = ...) -> None: ...
